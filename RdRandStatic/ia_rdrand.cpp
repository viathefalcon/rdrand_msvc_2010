// ia_rdrand.cpp: Implements the functions for working with the RDRAND instruction on (certain) Intel processors.
//
// Author: Stephen Higgins
// @viathefalcon
//

// Includes
//

// Precompiled Headers
#include "Stdafx.h"

// Declarations
#include "ia_rdrand.h"

// Macros
//

// Defines the RDRAND instruction in terms of its opcode
#define rdrand_eax	__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0

// Defines the bit mask used to examine the ecx register returned by cpuid.
// (The 30th bit is set.)
#define RDRAND_MASK	0x40000000

// Defines the result returned when the RDRAND instruction is supported by the host hardware
#define RDRAND_SUPPORTED 0

// Defines the result returned when the RDRAND instruction is unsupported by the host hardware
#define RDRAND_UNSUPPORTED 1

// Defines the result returned when whether or not the hardware supports the RDRAND instruction is unknown
#define RDRAND_SUPPORT_UNKNOWN 2

// Defines the maximum (32-bit) value generated by RDRAND, as a float
#define RDRAND_MAX_FLOAT 4294967295.f

// Functions
//

// Packs the four characters in the given buffer into an integer and compares with the comparand;
// returns true if equal; false otherwise
//
// Could do this with memcmp, of course, but don't want to link in the C/C++ runtime.
inline bool packcmp(int comparand, __in_bcount(4) const char* buffer) {

	const int packed = *((int*) buffer);
	return (packed == comparand);
}

// Queries CPUID to see if the RDRAND instruction is supported
bool rdrand_cpuid(void) {

	// Check if we are on supported hardware
	int info[4] = { -1, -1, -1, -1 };
	__cpuid( info, 0 );
	if ((packcmp( info[1], "Genu" ) &&
		packcmp( info[3], "ineI" ) &&
		packcmp( info[2], "ntel" )) || 
		(packcmp( info[1], "Auth" ) &&
		packcmp( info[3], "enti" ) &&
		packcmp( info[2], "cAMD" ))) {
		// Query the feature itself
		__cpuid( info, 1 );
		return ((info[2] & RDRAND_MASK) == RDRAND_MASK); // info[2] == ecx
	}
	return false;
}

bool RDRAND_CALLTYPE rdrand_supported(void) {

	// Caching the result is cheaper than re-invoking cpuid
	static unsigned supported = RDRAND_SUPPORT_UNKNOWN;
	if (supported == RDRAND_SUPPORT_UNKNOWN){
		supported = (rdrand_cpuid( ) ? RDRAND_SUPPORTED : RDRAND_UNSUPPORTED);
	}
	return (supported == RDRAND_SUPPORTED);
}

#ifndef _WIN64
bool RDRAND_CALLTYPE rdrand_next(__deref_out uint32_t* dest) {

	__asm {
		xor eax, eax		; Indicate to VC++ that we'll be using EAX, EDX
		xor edx, edx;

		rdrand_eax			; Get the random value into EAX
		jc rdrand_rslt		; If a value was available, jump down
		mov eax, 0			; Set the result (false)
		jmp rdrand_ret		; Jump over the next bit to get out of the function

	rdrand_rslt:
		mov edx, dest		; Move the address in the dest parameter into EDX
		mov [edx], eax		; Move the random value from EAX into the destination address (now in EDX)
		mov eax, 1			; Set the result (true)

	rdrand_ret:
		; Fall out here
	}

	// Return here with the result in EAX
	;
}

uint32_t RDRAND_CALLTYPE rdrand_uniform_ex(__in uint32_t lower, __in uint32_t upper) {

	uint32_t v = lower, r = 0, b = (upper - 1 - lower);
	__asm {
		xor eax, eax			; Indicate to VC++ that we'll be using EAX
		xor edx, edx			; and EDX

		rdrand_eax				; Get the random value into EAX
		jnc rdrand_ret			; No value available; jump over the next bit

		; At this point, the random value is in EAX and the range in b;
		; we regard the contents of EAX as the fractional part [3] of a 64-bit
		; unsigned fixed point number (where the integer part is 0) and the
		; contents of b as the integer part of a 64-bit fixed point number
		; (where the fractional part is 0).
		;
		; Because the top and bottom 32 bits, respectively, of our would-be 64-bit
		; inputs will always be zero we need only multiply the other 32 bits of each,
		; to obtain the middle 64 bits of the product. Conveniently, we have 
		; just the instruction for this..
		mul b

		; The 64-bit fixed point product (integer:fraction) is given in EDX:EAX,
		; and by discarding the latter, we effectively truncate, to give us a
		; number n, 0 <= n < (upper - lower); adding lower (in v) gives us n, lower <= n < upper
		add v, edx
		mov r, 1				; Set the result (true)

	rdrand_ret:
		; Fall out here
	}
	return (r == 0) ? upper : v;
}
#endif
